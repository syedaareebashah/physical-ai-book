"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[7446],{6604:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module1-ros2/core-concepts","title":"Core Concepts: Nodes, Topics, Services","description":"Chapter Objectives","source":"@site/docs/module1-ros2/02-core-concepts.md","sourceDirName":"module1-ros2","slug":"/module1-ros2/core-concepts","permalink":"/physical-ai-book/docs/module1-ros2/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/syedaareebashah/physical-ai-book/edit/main/docs/module1-ros2/02-core-concepts.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to ROS 2","permalink":"/physical-ai-book/docs/module1-ros2/introduction"},"next":{"title":"Your First ROS 2 Node","permalink":"/physical-ai-book/docs/module1-ros2/first-node"}}');var r=i(4848),t=i(8453);const l={sidebar_position:2},o="Core Concepts: Nodes, Topics, Services",c={},a=[{value:"Chapter Objectives",id:"chapter-objectives",level:2},{value:"Understanding Nodes",id:"understanding-nodes",level:2},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Creating a Node in Python",id:"creating-a-node-in-python",level:3},{value:"Topics and Publish/Subscribe Pattern",id:"topics-and-publishsubscribe-pattern",level:2},{value:"Topic Communication Characteristics",id:"topic-communication-characteristics",level:3},{value:"Quality of Service (QoS) Settings",id:"quality-of-service-qos-settings",level:3},{value:"Services and Client/Server Pattern",id:"services-and-clientserver-pattern",level:2},{value:"Service Implementation",id:"service-implementation",level:3},{value:"Physical AI Applications",id:"physical-ai-applications",level:2},{value:"Sensor Data Pipeline",id:"sensor-data-pipeline",level:3},{value:"Example: Camera Data Pipeline",id:"example-camera-data-pipeline",level:3},{value:"Best Practices for Physical AI",id:"best-practices-for-physical-ai",level:2},{value:"Node Design Principles",id:"node-design-principles",level:3},{value:"Communication Patterns",id:"communication-patterns",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"core-concepts-nodes-topics-services",children:"Core Concepts: Nodes, Topics, Services"})}),"\n",(0,r.jsx)(n.h2,{id:"chapter-objectives",children:"Chapter Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create and run ROS 2 nodes in both Python and C++"}),"\n",(0,r.jsx)(n.li,{children:"Implement topic-based communication between nodes"}),"\n",(0,r.jsx)(n.li,{children:"Design service-based request/reply interactions"}),"\n",(0,r.jsx)(n.li,{children:"Understand the publish/subscribe and client/server patterns"}),"\n",(0,r.jsx)(n.li,{children:"Apply these concepts to Physical AI scenarios"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"understanding-nodes",children:"Understanding Nodes"}),"\n",(0,r.jsx)(n.p,{children:"A node is an executable that uses ROS 2 to communicate with other nodes. Nodes are the fundamental building blocks of ROS 2 applications."}),"\n",(0,r.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"Nodes in ROS 2 follow a specific lifecycle:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unconfigured"}),": Initial state after creation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inactive"}),": Configured but not active"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Active"}),": Running and processing callbacks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Finalized"}),": Cleaned up and ready for destruction"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-node-in-python",children:"Creating a Node in Python"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass TalkerNode(Node):\n    def __init__(self):\n        super().__init__('talker')\n        self.publisher = self.create_publisher(String, 'chatter', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    talker = TalkerNode()\n    rclpy.spin(talker)\n    talker.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"topics-and-publishsubscribe-pattern",children:"Topics and Publish/Subscribe Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Topics enable asynchronous, decoupled communication between nodes using a publish/subscribe pattern."}),"\n",(0,r.jsx)(n.h3,{id:"topic-communication-characteristics",children:"Topic Communication Characteristics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Many-to-many"}),": Multiple publishers and subscribers can use the same topic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous"}),": Publishers and subscribers don't need to run simultaneously"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Typed"}),": Messages follow specific data types defined in ",(0,r.jsx)(n.code,{children:".msg"})," files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Buffered"}),": Messages are queued when publishers outpace subscribers"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"quality-of-service-qos-settings",children:"Quality of Service (QoS) Settings"}),"\n",(0,r.jsx)(n.p,{children:"QoS settings allow fine-tuning communication behavior:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\n\n# For real-time sensor data\nsensor_qos = QoSProfile(\n    depth=10,\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    durability=DurabilityPolicy.VOLATILE\n)\n\n# For critical control commands\ncontrol_qos = QoSProfile(\n    depth=1,\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.TRANSIENT_LOCAL\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"services-and-clientserver-pattern",children:"Services and Client/Server Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Services provide synchronous request/reply communication for actions requiring responses."}),"\n",(0,r.jsx)(n.h3,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Service definition (in srv/AddTwoInts.srv)\n# int64 a\n# int64 b\n# ---\n# int64 sum\n\n# Service server\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass AddTwoIntsService(Node):\n    def __init__(self):\n        super().__init__('add_two_ints_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Returning {request.a} + {request.b} = {response.sum}')\n        return response\n\n# Service client\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass AddTwoIntsClient(Node):\n    def __init__(self):\n        super().__init__('add_two_ints_client')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"physical-ai-applications",children:"Physical AI Applications"}),"\n",(0,r.jsx)(n.h3,{id:"sensor-data-pipeline",children:"Sensor Data Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"In Physical AI systems, nodes often form a pipeline:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Nodes"}),": Publish raw sensor data (camera images, LiDAR scans)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Processing Nodes"}),": Subscribe to sensor data, perform perception tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decision Nodes"}),": Use processed information for planning and control"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-camera-data-pipeline",children:"Example: Camera Data Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Camera driver node (publisher)\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nimport cv2\n\nclass CameraNode(Node):\n    def __init__(self):\n        super().__init__('camera_publisher')\n        self.publisher = self.create_publisher(Image, 'camera/image_raw', 10)\n        self.timer = self.create_timer(0.1, self.capture_image)  # 10Hz\n        self.cap = cv2.VideoCapture(0)\n\n    def capture_image(self):\n        ret, frame = self.cap.read()\n        if ret:\n            # Convert OpenCV image to ROS Image message\n            # (simplified - actual implementation requires cv2_to_imgmsg)\n            pass\n\n# Object detection node (subscriber)\nclass ObjectDetectionNode(Node):\n    def __init__(self):\n        super().__init__('object_detection')\n        self.subscription = self.create_subscription(\n            Image,\n            'camera/image_raw',\n            self.image_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def image_callback(self, msg):\n        # Process image for object detection\n        # Publish results to another topic\n        pass\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-for-physical-ai",children:"Best Practices for Physical AI"}),"\n",(0,r.jsx)(n.h3,{id:"node-design-principles",children:"Node Design Principles"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Responsibility"}),": Each node should perform one primary function"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Modularity"}),": Design nodes to be reusable across different robots"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robustness"}),": Handle errors gracefully and provide meaningful logging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Optimize for real-time constraints in Physical AI systems"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate QoS settings"})," for different types of data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize message size"})," for bandwidth-constrained scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper error handling"})," for network interruptions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider message frequency"})," to avoid overwhelming the system"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,r.jsx)(n.p,{children:"Nodes, topics, and services form the core communication infrastructure of ROS 2. Understanding these concepts is essential for building distributed Physical AI systems. The publish/subscribe pattern enables decoupled sensor processing pipelines, while services provide synchronous interfaces for critical operations."}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Create a simple ROS 2 node that publishes random sensor data and another that subscribes to it."}),"\n",(0,r.jsx)(n.li,{children:"Design a service that calculates the distance between two 3D points for robot navigation."}),"\n",(0,r.jsx)(n.li,{children:"Explain when you would use topics vs services in a Physical AI application."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"In the next chapter, we'll create our first complete ROS 2 node and run it in a practical example."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);