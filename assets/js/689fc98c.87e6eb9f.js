"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[2203],{5326:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module2-simulation/gazebo-fundamentals","title":"Gazebo Fundamentals","description":"Chapter Objectives","source":"@site/docs/module2-simulation/02-gazebo-fundamentals.md","sourceDirName":"module2-simulation","slug":"/module2-simulation/gazebo-fundamentals","permalink":"/physical-ai-book/docs/module2-simulation/gazebo-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/syedaareebashah/physical-ai-book/edit/main/docs/module2-simulation/02-gazebo-fundamentals.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Robot Simulation","permalink":"/physical-ai-book/docs/module2-simulation/introduction"},"next":{"title":"Simulating Sensors (LiDAR, Cameras, IMU)","permalink":"/physical-ai-book/docs/module2-simulation/simulating-sensors"}}');var s=i(4848),r=i(8453);const l={sidebar_position:2},o="Gazebo Fundamentals",t={},c=[{value:"Chapter Objectives",id:"chapter-objectives",level:2},{value:"Gazebo Architecture",id:"gazebo-architecture",level:2},{value:"Server Components",id:"server-components",level:3},{value:"Client Components",id:"client-components",level:3},{value:"Launching Gazebo",id:"launching-gazebo",level:2},{value:"Basic Launch",id:"basic-launch",level:3},{value:"World Files and SDF Format",id:"world-files-and-sdf-format",level:2},{value:"Basic World Structure",id:"basic-world-structure",level:3},{value:"Creating Custom Worlds",id:"creating-custom-worlds",level:2},{value:"Simple Obstacle World",id:"simple-obstacle-world",level:3},{value:"Spawning Robots in Gazebo",id:"spawning-robots-in-gazebo",level:2},{value:"Using Command Line",id:"using-command-line",level:3},{value:"Using ROS 2 Service Calls",id:"using-ros-2-service-calls",level:3},{value:"Physics Configuration",id:"physics-configuration",level:2},{value:"Understanding Physics Parameters",id:"understanding-physics-parameters",level:3},{value:"Performance vs. Accuracy Trade-offs",id:"performance-vs-accuracy-trade-offs",level:3},{value:"Sensor Simulation in Gazebo",id:"sensor-simulation-in-gazebo",level:2},{value:"Camera Sensor",id:"camera-sensor",level:3},{value:"LiDAR Sensor",id:"lidar-sensor",level:3},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"Gazebo ROS Packages",id:"gazebo-ros-packages",level:3},{value:"Controller Configuration",id:"controller-configuration",level:3},{value:"Physical AI Simulation Scenarios",id:"physical-ai-simulation-scenarios",level:2},{value:"Navigation Simulation",id:"navigation-simulation",level:3},{value:"Manipulation Simulation",id:"manipulation-simulation",level:3},{value:"Best Practices for Physical AI Simulation",id:"best-practices-for-physical-ai-simulation",level:2},{value:"Model Accuracy",id:"model-accuracy",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"gazebo-fundamentals",children:"Gazebo Fundamentals"})}),"\n",(0,s.jsx)(n.h2,{id:"chapter-objectives",children:"Chapter Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Launch and configure Gazebo simulation environments"}),"\n",(0,s.jsx)(n.li,{children:"Create and customize simulation worlds"}),"\n",(0,s.jsx)(n.li,{children:"Spawn and control robots in Gazebo"}),"\n",(0,s.jsx)(n.li,{children:"Configure physics properties and parameters"}),"\n",(0,s.jsx)(n.li,{children:"Integrate Gazebo with ROS 2 for Physical AI applications"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo is built on a client-server architecture:"}),"\n",(0,s.jsx)(n.h3,{id:"server-components",children:"Server Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Server"}),": Handles physics simulation, sensors, and plugins"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Engine"}),": Simulates rigid body dynamics (ODE, Bullet, DART)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor System"}),": Emulates various sensors with realistic properties"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"client-components",children:"Client Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Client"}),": Provides the graphical user interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model Database"}),": Stores robot and environment models (Fuel)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"launching-gazebo",children:"Launching Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"basic-launch",children:"Basic Launch"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Launch Gazebo with default empty world\ngz sim -r\n\n# Launch with a specific world file\ngz sim -r -v 4 empty.sdf  # Higher verbosity for debugging\n"})}),"\n",(0,s.jsx)(n.p,{children:"For ROS 2 integration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Launch through ROS 2 launch system\nros2 launch gazebo_ros gazebo.launch.py\n\n# Launch with custom world\nros2 launch gazebo_ros gazebo.launch.py world:=/path/to/world.sdf\n"})}),"\n",(0,s.jsx)(n.h2,{id:"world-files-and-sdf-format",children:"World Files and SDF Format"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo uses SDF (Simulation Description Format) to define simulation worlds:"}),"\n",(0,s.jsx)(n.h3,{id:"basic-world-structure",children:"Basic World Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="my_world">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Environment lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.4 0.2 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n            <specular>0.7 0.7 0.7 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Your robot will go here --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"creating-custom-worlds",children:"Creating Custom Worlds"}),"\n",(0,s.jsx)(n.h3,{id:"simple-obstacle-world",children:"Simple Obstacle World"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="obstacle_course">\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.4 0.2 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane><normal>0 0 1</normal></plane>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane><normal>0 0 1</normal></plane>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Obstacles --\x3e\n    <model name="obstacle_1">\n      <pose>2 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box><size>1 0.2 1</size></box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box><size>1 0.2 1</size></box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n            <diffuse>0.8 0.2 0.2 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.1667</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.1667</iyy>\n            <iyz>0</iyz>\n            <izz>0.1667</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- More obstacles can be added --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"spawning-robots-in-gazebo",children:"Spawning Robots in Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"using-command-line",children:"Using Command Line"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Spawn a model from the model database\ngz model -f model.sdf -m robot_name --model-name robot_name\n\n# For ROS 2\nros2 run gazebo_ros spawn_entity.py -file /path/to/robot.urdf -entity my_robot -x 0 -y 0 -z 1\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-ros-2-service-calls",children:"Using ROS 2 Service Calls"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom gazebo_msgs.srv import SpawnEntity\n\nclass RobotSpawner(Node):\n    def __init__(self):\n        super().__init__('robot_spawner')\n        self.cli = self.create_client(SpawnEntity, '/spawn_entity')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n    def spawn_robot(self, robot_xml, robot_name, initial_pose):\n        req = SpawnEntity.Request()\n        req.name = robot_name\n        req.xml = robot_xml\n        req.initial_pose.position.x = initial_pose[0]\n        req.initial_pose.position.y = initial_pose[1]\n        req.initial_pose.position.z = initial_pose[2]\n\n        future = self.cli.call_async(req)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            self.get_logger().info(f'Successfully spawned {robot_name}')\n        else:\n            self.get_logger().error(f'Failed to spawn {robot_name}')\n"})}),"\n",(0,s.jsx)(n.h2,{id:"physics-configuration",children:"Physics Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"understanding-physics-parameters",children:"Understanding Physics Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics type="ode">\n  \x3c!-- Time step for physics updates --\x3e\n  <max_step_size>0.001</max_step_size>\n\n  \x3c!-- Real-time factor (1.0 = real-time, >1 = faster than real-time) --\x3e\n  <real_time_factor>1.0</real_time_factor>\n\n  \x3c!-- Physics updates per second --\x3e\n  <real_time_update_rate>1000</real_time_update_rate>\n\n  \x3c!-- Gravity --\x3e\n  <gravity>0 0 -9.8</gravity>\n\n  \x3c!-- ODE-specific parameters --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>10</iters>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"performance-vs-accuracy-trade-offs",children:"Performance vs. Accuracy Trade-offs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Smaller time steps"}),": More accurate but slower simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Higher real-time factor"}),": Faster simulation but potentially unstable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"More solver iterations"}),": Better stability but slower performance"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sensor-simulation-in-gazebo",children:"Sensor Simulation in Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"camera-sensor",children:"Camera Sensor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <always_on>true</always_on>\n  <update_rate>30</update_rate>\n  <camera name="head">\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>10.0</far>\n    </clip>\n  </camera>\n  <plugin filename="libgazebo_ros_camera.so" name="camera_controller">\n    <frame_name>camera_frame</frame_name>\n    <topic_name>/camera/image_raw</topic_name>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"lidar-sensor",children:"LiDAR Sensor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor name="lidar" type="ray">\n  <always_on>true</always_on>\n  <update_rate>10</update_rate>\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>360</samples>\n        <resolution>1.0</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>10.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n  <plugin filename="libgazebo_ros_ray_sensor.so" name="lidar_controller">\n    <ros_topic>/scan</ros_topic>\n    <frame_name>lidar_frame</frame_name>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-ros-packages",children:"Gazebo ROS Packages"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"gazebo_ros_pkgs"})," provide the bridge between Gazebo and ROS 2:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In your robot\'s URDF/Xacro --\x3e\n<gazebo>\n  <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n    <parameters>$(find my_robot_package)/config/my_robot_controllers.yaml</parameters>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"controller-configuration",children:"Controller Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# config/my_robot_controllers.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    arm_controller:\n      type: position_controllers/JointGroupPositionController\n\narm_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n      - joint3\n"})}),"\n",(0,s.jsx)(n.h2,{id:"physical-ai-simulation-scenarios",children:"Physical AI Simulation Scenarios"}),"\n",(0,s.jsx)(n.h3,{id:"navigation-simulation",children:"Navigation Simulation"}),"\n",(0,s.jsx)(n.p,{children:"Setting up a world for navigation testing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In your world file --\x3e\n\x3c!-- Add various obstacles with different shapes and sizes --\x3e\n<model name="wall_1">\n  <pose>5 0 1 0 0 0</pose>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <box><size>0.1 10 2</size></box>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <box><size>0.1 10 2</size></box>\n      </geometry>\n      <material><ambient>0.5 0.5 0.5 1</ambient></material>\n    </visual>\n  </link>\n</model>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"manipulation-simulation",children:"Manipulation Simulation"}),"\n",(0,s.jsx)(n.p,{children:"Creating objects for manipulation tasks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add objects that can be grasped --\x3e\n<model name="graspable_object">\n  <pose>1 1 0.5 0 0 0</pose>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <cylinder><radius>0.05</radius><length>0.2</length></cylinder>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <cylinder><radius>0.05</radius><length>0.2</length></cylinder>\n      </geometry>\n      <material><ambient>0.2 0.8 0.2 1</ambient></material>\n    </visual>\n    <inertial>\n      <mass>0.1</mass>\n      <inertia><ixx>0.001</ixx><iyy>0.001</iyy><izz>0.0005</izz></inertia>\n    </inertial>\n  </link>\n</model>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-physical-ai-simulation",children:"Best Practices for Physical AI Simulation"}),"\n",(0,s.jsx)(n.h3,{id:"model-accuracy",children:"Model Accuracy"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use realistic mass and inertia properties"}),"\n",(0,s.jsx)(n.li,{children:"Include appropriate friction coefficients"}),"\n",(0,s.jsx)(n.li,{children:"Model sensor noise and limitations"}),"\n",(0,s.jsx)(n.li,{children:"Validate simulation against real-world data"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use simplified collision geometry for planning"}),"\n",(0,s.jsx)(n.li,{children:"Optimize visual geometry separately from collision geometry"}),"\n",(0,s.jsx)(n.li,{children:"Adjust physics parameters based on simulation requirements"}),"\n",(0,s.jsx)(n.li,{children:"Use appropriate update rates for different sensors"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement simulation bounds to prevent robot wandering"}),"\n",(0,s.jsx)(n.li,{children:"Include emergency stop mechanisms in simulation"}),"\n",(0,s.jsx)(n.li,{children:"Test failure scenarios safely in simulation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo provides a powerful simulation environment for Physical AI applications with native ROS 2 integration. Understanding SDF world files, physics configuration, and sensor simulation enables the creation of realistic environments for testing robotic systems. Proper integration with ROS 2 allows seamless transition between simulation and real hardware."}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a simple world file with a robot and several obstacles."}),"\n",(0,s.jsx)(n.li,{children:"Configure a camera sensor in Gazebo and verify it publishes ROS 2 messages."}),"\n",(0,s.jsx)(n.li,{children:"Adjust physics parameters to optimize simulation performance vs. accuracy."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"In the next chapter, we'll explore simulating various types of sensors for Physical AI applications, including cameras, LiDAR, IMU, and force/torque sensors."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var a=i(6540);const s={},r=a.createContext(s);function l(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);