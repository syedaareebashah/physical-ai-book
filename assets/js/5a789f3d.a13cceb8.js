"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[3004],{8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>o});var s=i(6540);const t={},a=s.createContext(t);function l(n){const e=s.useContext(a);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),s.createElement(a.Provider,{value:e},n.children)}},8509:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module2-simulation/building-environments","title":"Building Test Environments","description":"Chapter Objectives","source":"@site/docs/module2-simulation/05-building-environments.md","sourceDirName":"module2-simulation","slug":"/module2-simulation/building-environments","permalink":"/physical-ai-book/docs/module2-simulation/building-environments","draft":false,"unlisted":false,"editUrl":"https://github.com/syedaareebashah/physical-ai-book/edit/main/docs/module2-simulation/05-building-environments.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Unity for High-Fidelity Rendering","permalink":"/physical-ai-book/docs/module2-simulation/unity-rendering"},"next":{"title":"Project: Autonomous Navigation in Simulation","permalink":"/physical-ai-book/docs/module2-simulation/project"}}');var t=i(4848),a=i(8453);const l={sidebar_position:5},o="Building Test Environments",r={},c=[{value:"Chapter Objectives",id:"chapter-objectives",level:2},{value:"Environment Design Principles for Physical AI",id:"environment-design-principles-for-physical-ai",level:2},{value:"Realism vs. Complexity Balance",id:"realism-vs-complexity-balance",level:3},{value:"Environmental Complexity Levels",id:"environmental-complexity-levels",level:3},{value:"Level 1: Basic Validation",id:"level-1-basic-validation",level:4},{value:"Level 2: Intermediate Challenges",id:"level-2-intermediate-challenges",level:4},{value:"Level 3: Advanced Testing",id:"level-3-advanced-testing",level:4},{value:"Gazebo Environment Construction",id:"gazebo-environment-construction",level:2},{value:"Creating Modular World Components",id:"creating-modular-world-components",level:3},{value:"Navigation Test Environments",id:"navigation-test-environments",level:3},{value:"Manipulation Test Environments",id:"manipulation-test-environments",level:3},{value:"Unity Environment Construction",id:"unity-environment-construction",level:2},{value:"Procedural Environment Generation",id:"procedural-environment-generation",level:3},{value:"Dynamic Environment Elements",id:"dynamic-environment-elements",level:3},{value:"Environment Validation and Metrics",id:"environment-validation-and-metrics",level:2},{value:"Performance Metrics Framework",id:"performance-metrics-framework",level:3},{value:"Multi-Environment Testing Framework",id:"multi-environment-testing-framework",level:2},{value:"Environment Switching System",id:"environment-switching-system",level:3},{value:"Physical AI Environment Considerations",id:"physical-ai-environment-considerations",level:2},{value:"Real-World Scenario Replication",id:"real-world-scenario-replication",level:3},{value:"Safety and Validation",id:"safety-and-validation",level:3},{value:"Best Practices for Environment Design",id:"best-practices-for-environment-design",level:2},{value:"Modularity",id:"modularity",level:3},{value:"Scalability",id:"scalability",level:3},{value:"Validation",id:"validation",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"building-test-environments",children:"Building Test Environments"})}),"\n",(0,t.jsx)(e.h2,{id:"chapter-objectives",children:"Chapter Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Design comprehensive test environments for Physical AI systems"}),"\n",(0,t.jsx)(e.li,{children:"Create obstacle courses and navigation challenges"}),"\n",(0,t.jsx)(e.li,{children:"Build manipulation and interaction scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Implement multi-environment testing frameworks"}),"\n",(0,t.jsx)(e.li,{children:"Validate robot performance across diverse environments"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"environment-design-principles-for-physical-ai",children:"Environment Design Principles for Physical AI"}),"\n",(0,t.jsx)(e.h3,{id:"realism-vs-complexity-balance",children:"Realism vs. Complexity Balance"}),"\n",(0,t.jsx)(e.p,{children:"When building test environments for Physical AI, consider:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Deployment Fidelity"}),": How closely does the environment match real deployment scenarios?"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Computational Efficiency"}),": Can the environment run in real-time for testing?"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Variety"}),": Does the environment test diverse scenarios and edge cases?"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Measurability"}),": Can you quantify robot performance in the environment?"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"environmental-complexity-levels",children:"Environmental Complexity Levels"}),"\n",(0,t.jsx)(e.h4,{id:"level-1-basic-validation",children:"Level 1: Basic Validation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Simple, open spaces"}),"\n",(0,t.jsx)(e.li,{children:"Basic geometric obstacles"}),"\n",(0,t.jsx)(e.li,{children:"Static environments"}),"\n",(0,t.jsx)(e.li,{children:"Single-task scenarios"}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"level-2-intermediate-challenges",children:"Level 2: Intermediate Challenges"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Complex geometries"}),"\n",(0,t.jsx)(e.li,{children:"Multiple simultaneous tasks"}),"\n",(0,t.jsx)(e.li,{children:"Dynamic elements"}),"\n",(0,t.jsx)(e.li,{children:"Varying lighting conditions"}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"level-3-advanced-testing",children:"Level 3: Advanced Testing"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Real-world inspired scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Multiple robots interaction"}),"\n",(0,t.jsx)(e.li,{children:"Environmental disturbances"}),"\n",(0,t.jsx)(e.li,{children:"Long-term autonomy tests"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"gazebo-environment-construction",children:"Gazebo Environment Construction"}),"\n",(0,t.jsx)(e.h3,{id:"creating-modular-world-components",children:"Creating Modular World Components"}),"\n",(0,t.jsx)(e.p,{children:"Building reusable environment components:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- reusable_wall.sdf --\x3e\n<sdf version="1.7">\n  <model name="reusable_wall">\n    <pose>0 0 0 0 0 0</pose>\n    <link name="wall_link">\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>3 0.2 2</size>\n          </box>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>3 0.2 2</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.5 0.5 0.5 1</ambient>\n          <diffuse>0.5 0.5 0.5 1</diffuse>\n          <specular>0.5 0.5 0.5 1</specular>\n        </material>\n      </visual>\n      <inertial>\n        <mass>10.0</mass>\n        <inertia>\n          <ixx>1.0</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>1.0</iyy>\n          <iyz>0</iyz>\n          <izz>1.0</izz>\n        </inertia>\n      </inertial>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"navigation-test-environments",children:"Navigation Test Environments"}),"\n",(0,t.jsx)(e.p,{children:"Creating challenging navigation scenarios:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="navigation_challenge">\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.4 0.2 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Outer walls --\x3e\n    <model name="outer_wall_north">\n      <pose>0 5 1 0 0 0</pose>\n      <include>\n        <uri>model://reusable_wall</uri>\n      </include>\n    </model>\n\n    <model name="outer_wall_south">\n      <pose>0 -5 1 0 0 3.14159</pose>\n      <include>\n        <uri>model://reusable_wall</uri>\n      </include>\n    </model>\n\n    <model name="outer_wall_east">\n      <pose>5 0 1 0 0 1.5708</pose>\n      <include>\n        <uri>model://reusable_wall</uri>\n      </include>\n    </model>\n\n    <model name="outer_wall_west">\n      <pose>-5 0 1 0 0 -1.5708</pose>\n      <include>\n        <uri>model://reusable_wall</uri>\n      </include>\n    </model>\n\n    \x3c!-- Interior obstacles --\x3e\n    <model name="narrow_passage_wall1">\n      <pose>0 2 1 0 0 0</pose>\n      <include>\n        <uri>model://reusable_wall</uri>\n      </include>\n    </model>\n\n    <model name="narrow_passage_wall2">\n      <pose>0 -2 1 0 0 0</pose>\n      <include>\n        <uri>model://reusable_wall</uri>\n      </include>\n    </model>\n\n    \x3c!-- Create a gap in the middle --\x3e\n    <model name="gap_filler">\n      <pose>0 0 1 0 0 0</pose>\n      <link name="link">\n        <visual name="visual">\n          <geometry>\n            <box><size>0.5 0.1 0.1</size>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Moving obstacles --\x3e\n    <model name="moving_obstacle">\n      <pose>2 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <sphere><radius>0.3</radius></sphere>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <sphere><radius>0.3</radius></sphere>\n          </geometry>\n          <material><ambient>0.8 0.2 0.2 1</ambient></material>\n        </visual>\n        <inertial>\n          <mass>1.0</mass>\n          <inertia><ixx>0.1</ixx><iyy>0.1</iyy><izz>0.1</izz></inertia>\n        </inertial>\n      </link>\n      \x3c!-- Add plugin for movement --\x3e\n      <plugin filename="libgazebo_ros_p3d.so" name="moving_obstacle_controller">\n        <alwaysOn>true</alwaysOn>\n        <updateRate>30</updateRate>\n        <bodyName>link</bodyName>\n        <topicName>/moving_obstacle/pose</topicName>\n        <gaussianNoise>0.0</gaussianNoise>\n        <frameName>map</frameName>\n      </plugin>\n    </model>\n\n    \x3c!-- Goal marker --\x3e\n    <model name="goal_marker">\n      <pose>4 0 0.1 0 0 0</pose>\n      <link name="link">\n        <visual name="visual">\n          <geometry>\n            <cylinder><radius>0.2</radius><length>0.2</length></cylinder>\n          </geometry>\n          <material><ambient>0.2 0.8 0.2 1</ambient></material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"manipulation-test-environments",children:"Manipulation Test Environments"}),"\n",(0,t.jsx)(e.p,{children:"Creating environments for manipulation tasks:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="manipulation_lab">\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.4 0.2 -0.9</direction>\n    </light>\n\n    \x3c!-- Workbench --\x3e\n    <model name="workbench">\n      <pose>0 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box><size>2 1 1</size></box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box><size>2 1 1</size></box>\n          </geometry>\n          <material><ambient>0.6 0.4 0.2 1</ambient></material>\n        </visual>\n        <inertial>\n          <mass>50.0</mass>\n          <inertia>\n            <ixx>10.0</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>10.0</iyy>\n            <iyz>0</iyz>\n            <izz>10.0</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Objects to manipulate --\x3e\n    <model name="red_block">\n      <pose>-0.5 0.2 1.05 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box><size>0.1 0.1 0.1</size></box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box><size>0.1 0.1 0.1</size></box>\n          </geometry>\n          <material><ambient>0.8 0.2 0.2 1</ambient></material>\n        </visual>\n        <inertial>\n          <mass>0.1</mass>\n          <inertia>\n            <ixx>0.0001</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.0001</iyy>\n            <iyz>0</iyz>\n            <izz>0.0001</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    <model name="blue_cylinder">\n      <pose>-0.2 0.2 1.05 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <cylinder><radius>0.05</radius><length>0.1</length></cylinder>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <cylinder><radius>0.05</radius><length>0.1</length></cylinder>\n          </geometry>\n          <material><ambient>0.2 0.2 0.8 1</ambient></material>\n        </visual>\n        <inertial>\n          <mass>0.05</mass>\n          <inertia>\n            <ixx>0.0001</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.0001</iyy>\n            <iyz>0</iyz>\n            <izz>0.0002</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Target zones --\x3e\n    <model name="target_zone_red">\n      <pose>0.5 0.2 0.51 0 0 0</pose>\n      <link name="link">\n        <visual name="visual">\n          <geometry>\n            <box><size>0.3 0.3 0.02</size></box>\n          </geometry>\n          <material><ambient>0.8 0.2 0.2 0.5</ambient></material>\n        </visual>\n      </link>\n    </model>\n\n    <model name="target_zone_blue">\n      <pose>0.5 -0.2 0.51 0 0 0</pose>\n      <link name="link">\n        <visual name="visual">\n          <geometry>\n            <box><size>0.3 0.3 0.02</size></box>\n          </geometry>\n          <material><ambient>0.2 0.2 0.8 0.5</ambient></material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Storage bin --\x3e\n    <model name="storage_bin">\n      <pose>0.8 0 0.6 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box><size>0.4 0.4 0.2</size></box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box><size>0.4 0.4 0.2</size></box>\n          </geometry>\n          <material><ambient>0.4 0.4 0.4 1</ambient></material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"unity-environment-construction",children:"Unity Environment Construction"}),"\n",(0,t.jsx)(e.h3,{id:"procedural-environment-generation",children:"Procedural Environment Generation"}),"\n",(0,t.jsx)(e.p,{children:"Creating environments algorithmically in Unity:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'// Example: Procedural maze generator for navigation testing\nusing UnityEngine;\nusing System.Collections.Generic;\n\npublic class MazeGenerator : MonoBehaviour\n{\n    [Header("Maze Parameters")]\n    public int width = 20;\n    public int height = 20;\n    public GameObject wallPrefab;\n    public GameObject floorPrefab;\n\n    [Header("Navigation Goals")]\n    public Transform startMarker;\n    public Transform goalMarker;\n\n    private bool[,] mazeGrid;\n    private List<Vector3> pathPositions;\n\n    void Start()\n    {\n        GenerateMaze();\n        PlaceStartAndGoal();\n    }\n\n    void GenerateMaze()\n    {\n        mazeGrid = new bool[width, height];\n        pathPositions = new List<Vector3>();\n\n        // Initialize grid (all walls)\n        for (int x = 0; x < width; x++)\n        {\n            for (int z = 0; z < height; z++)\n            {\n                mazeGrid[x, z] = true; // true = wall, false = path\n            }\n        }\n\n        // Generate maze using recursive backtracking\n        GenerateMazeRecursive(1, 1);\n\n        // Create the actual game objects\n        CreateMazeObjects();\n    }\n\n    void GenerateMazeRecursive(int x, int z)\n    {\n        mazeGrid[x, z] = false; // Mark as path\n        pathPositions.Add(new Vector3(x, 0, z));\n\n        // Shuffle directions\n        List<Vector2Int> directions = new List<Vector2Int>\n        {\n            new Vector2Int(2, 0),   // Right\n            new Vector2Int(-2, 0),  // Left\n            new Vector2Int(0, 2),   // Up\n            new Vector2Int(0, -2)   // Down\n        };\n\n        directions.Shuffle(); // Extension method to shuffle list\n\n        foreach (Vector2Int dir in directions)\n        {\n            int newX = x + dir.x;\n            int newZ = z + dir.y;\n\n            if (newX > 0 && newX < width - 1 && newZ > 0 && newZ < height - 1 && mazeGrid[newX, newZ])\n            {\n                // Remove wall between current and new cell\n                mazeGrid[x + dir.x / 2, z + dir.y / 2] = false;\n                pathPositions.Add(new Vector3(x + dir.x / 2, 0, z + dir.y / 2));\n\n                GenerateMazeRecursive(newX, newZ);\n            }\n        }\n    }\n\n    void CreateMazeObjects()\n    {\n        // Create floor\n        GameObject floor = Instantiate(floorPrefab);\n        floor.transform.position = new Vector3(width / 2f, -0.5f, height / 2f);\n        floor.transform.localScale = new Vector3(width, 1, height);\n\n        // Create walls\n        for (int x = 0; x < width; x++)\n        {\n            for (int z = 0; z < height; z++)\n            {\n                if (mazeGrid[x, z])\n                {\n                    GameObject wall = Instantiate(wallPrefab);\n                    wall.transform.position = new Vector3(x, 0, z);\n                }\n            }\n        }\n    }\n\n    void PlaceStartAndGoal()\n    {\n        // Place start at beginning of path\n        if (pathPositions.Count > 0)\n        {\n            startMarker.position = pathPositions[0] + Vector3.up;\n        }\n\n        // Place goal at end of path\n        if (pathPositions.Count > 0)\n        {\n            goalMarker.position = pathPositions[pathPositions.Count - 1] + Vector3.up;\n        }\n    }\n}\n\n// Extension method for shuffling lists\npublic static class ListExtensions\n{\n    public static void Shuffle<T>(this IList<T> list)\n    {\n        System.Random rng = new System.Random();\n        int n = list.Count;\n        while (n > 1)\n        {\n            n--;\n            int k = rng.Next(n + 1);\n            T value = list[k];\n            list[k] = list[n];\n            list[n] = value;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"dynamic-environment-elements",children:"Dynamic Environment Elements"}),"\n",(0,t.jsx)(e.p,{children:"Creating environments with changing elements:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'// Example: Dynamic obstacle system\nusing UnityEngine;\nusing System.Collections;\n\npublic class DynamicEnvironment : MonoBehaviour\n{\n    [Header("Dynamic Elements")]\n    public GameObject[] movingObstacles;\n    public Transform[] obstaclePaths;\n    public float moveSpeed = 2.0f;\n\n    [Header("Environmental Changes")]\n    public GameObject[] toggleObjects;\n    public float changeInterval = 10.0f;\n\n    [Header("Weather System")]\n    public Light sunLight;\n    public AnimationCurve lightIntensityCurve;\n    public float dayNightCycleDuration = 120.0f;\n\n    private float timeSinceChange = 0f;\n    private float dayNightTime = 0f;\n\n    void Start()\n    {\n        StartCoroutine(MoveObstacles());\n        StartCoroutine(ChangeEnvironment());\n    }\n\n    IEnumerator MoveObstacles()\n    {\n        while (true)\n        {\n            foreach (GameObject obstacle in movingObstacles)\n            {\n                // Move obstacle along its path\n                MoveObstacle(obstacle);\n            }\n            yield return new WaitForSeconds(0.1f);\n        }\n    }\n\n    void MoveObstacle(GameObject obstacle)\n    {\n        // Simple back-and-forth movement\n        float moveDistance = moveSpeed * Time.deltaTime;\n        obstacle.transform.Translate(Vector3.forward * moveDistance);\n\n        // Check if reached end of path and reverse direction\n        if (Vector3.Distance(obstacle.transform.position, obstaclePaths[0].position) > 10f)\n        {\n            obstacle.transform.Rotate(0, 180, 0); // Turn around\n        }\n    }\n\n    IEnumerator ChangeEnvironment()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(changeInterval);\n            ToggleEnvironmentElements();\n        }\n    }\n\n    void ToggleEnvironmentElements()\n    {\n        foreach (GameObject obj in toggleObjects)\n        {\n            obj.SetActive(!obj.activeSelf);\n        }\n    }\n\n    void Update()\n    {\n        // Update day/night cycle\n        dayNightTime += Time.deltaTime / dayNightCycleDuration;\n        if (dayNightTime > 1) dayNightTime = 0;\n\n        float intensity = lightIntensityCurve.Evaluate(dayNightTime);\n        sunLight.intensity = intensity;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"environment-validation-and-metrics",children:"Environment Validation and Metrics"}),"\n",(0,t.jsx)(e.h3,{id:"performance-metrics-framework",children:"Performance Metrics Framework"}),"\n",(0,t.jsx)(e.p,{children:"Creating systems to measure robot performance:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# File: environment_evaluation/evaluation_metrics.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import Float32, Bool\nimport numpy as np\nfrom collections import deque\n\nclass EnvironmentEvaluator(Node):\n    def __init__(self):\n        super().__init__('environment_evaluator')\n\n        # Subscribers\n        self.pose_sub = self.create_subscription(\n            PoseStamped, '/robot_pose', self.pose_callback, 10)\n        self.scan_sub = self.create_subscription(\n            LaserScan, '/scan', self.scan_callback, 10)\n        self.cmd_sub = self.create_subscription(\n            Twist, '/cmd_vel', self.cmd_callback, 10)\n\n        # Publishers\n        self.completion_pub = self.create_publisher(Bool, '/task_completion', 10)\n        self.performance_pub = self.create_publisher(Float32, '/performance_score', 10)\n        self.collision_pub = self.create_publisher(Bool, '/collision_detected', 10)\n\n        # Parameters\n        self.declare_parameter('goal_position', [5.0, 0.0])\n        self.declare_parameter('navigation_timeout', 300)  # 5 minutes\n        self.declare_parameter('min_safe_distance', 0.3)\n\n        # State tracking\n        self.current_pose = None\n        self.start_time = self.get_clock().now()\n        self.collision_threshold = self.get_parameter('min_safe_distance').value\n        self.goal_position = self.get_parameter('goal_position').value\n        self.cmd_history = deque(maxlen=100)\n        self.pose_history = deque(maxlen=200)\n\n    def pose_callback(self, msg):\n        self.current_pose = msg.pose\n        self.pose_history.append((msg.header.stamp, msg.pose))\n\n        if self.current_pose:\n            self.evaluate_performance()\n\n    def scan_callback(self, msg):\n        # Check for collisions based on laser scan\n        min_distance = min(msg.ranges) if msg.ranges else float('inf')\n\n        collision_msg = Bool()\n        collision_msg.data = min_distance < self.collision_threshold\n        self.collision_pub.publish(collision_msg)\n\n    def cmd_callback(self, msg):\n        self.cmd_history.append(msg)\n\n    def evaluate_performance(self):\n        if not self.current_pose:\n            return\n\n        # Calculate distance to goal\n        pos = self.current_pose.position\n        distance_to_goal = np.sqrt(\n            (pos.x - self.goal_position[0])**2 +\n            (pos.y - self.goal_position[1])**2\n        )\n\n        # Check if goal reached\n        if distance_to_goal < 0.5:  # 50cm tolerance\n            completion_msg = Bool()\n            completion_msg.data = True\n            self.completion_pub.publish(completion_msg)\n            self.get_logger().info(f'Goal reached! Time: {(self.get_clock().now() - self.start_time).nanoseconds / 1e9:.2f}s')\n            return\n\n        # Calculate performance score\n        # Factors: distance to goal, time taken, collision avoidance, smoothness\n        time_elapsed = (self.get_clock().now() - self.start_time).nanoseconds / 1e9\n        distance_score = 1.0 / (1.0 + distance_to_goal)  # Higher score for closer to goal\n        time_score = max(0, 1.0 - (time_elapsed / self.get_parameter('navigation_timeout').value))\n\n        # Smoothness score based on command history\n        smoothness_score = self.calculate_smoothness_score()\n\n        performance_score = (distance_score * 0.4 + time_score * 0.3 + smoothness_score * 0.3)\n\n        perf_msg = Float32()\n        perf_msg.data = performance_score\n        self.performance_pub.publish(perf_msg)\n\n    def calculate_smoothness_score(self):\n        if len(self.cmd_history) < 2:\n            return 1.0\n\n        # Calculate command variation (lower variation = smoother)\n        linear_vels = [cmd.linear.x for cmd in self.cmd_history]\n        angular_vels = [cmd.angular.z for cmd in self.cmd_history]\n\n        linear_variation = np.std(linear_vels) if len(set(linear_vels)) > 1 else 0\n        angular_variation = np.std(angular_vels) if len(set(angular_vels)) > 1 else 0\n\n        # Normalize to 0-1 range (lower variation = higher score)\n        smoothness = 1.0 / (1.0 + linear_variation + angular_variation)\n        return min(smoothness, 1.0)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    evaluator = EnvironmentEvaluator()\n\n    try:\n        rclpy.spin(evaluator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        evaluator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"multi-environment-testing-framework",children:"Multi-Environment Testing Framework"}),"\n",(0,t.jsx)(e.h3,{id:"environment-switching-system",children:"Environment Switching System"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# File: environment_evaluation/environment_manager.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import Trigger\nfrom std_msgs.msg import String\nimport subprocess\nimport time\n\nclass EnvironmentManager(Node):\n    def __init__(self):\n        super().__init__('environment_manager')\n\n        # Services for environment control\n        self.switch_env_srv = self.create_service(\n            Trigger, 'switch_environment', self.switch_environment_callback)\n        self.reset_env_srv = self.create_service(\n            Trigger, 'reset_environment', self.reset_environment_callback)\n\n        # Publisher for environment status\n        self.status_pub = self.create_publisher(String, '/environment_status', 10)\n\n        # Available environments\n        self.environments = {\n            'simple_navigation': 'worlds/simple_nav.sdf',\n            'complex_navigation': 'worlds/complex_nav.sdf',\n            'manipulation': 'worlds/manipulation.sdf',\n            'dynamic_obstacles': 'worlds/dynamic.sdf'\n        }\n\n        self.current_env = None\n\n    def switch_environment_callback(self, request, response):\n        # This would typically involve restarting Gazebo with a new world\n        response.success = True\n        response.message = f\"Environment switching not implemented in this example\"\n        return response\n\n    def reset_environment_callback(self, request, response):\n        # Reset environment to initial state\n        response.success = True\n        response.message = \"Environment reset complete\"\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    manager = EnvironmentManager()\n\n    try:\n        rclpy.spin(manager)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        manager.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"physical-ai-environment-considerations",children:"Physical AI Environment Considerations"}),"\n",(0,t.jsx)(e.h3,{id:"real-world-scenario-replication",children:"Real-World Scenario Replication"}),"\n",(0,t.jsx)(e.p,{children:"When building environments for Physical AI:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Deployment Environments"}),": Match the actual deployment location"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Human Interaction"}),": Include realistic human movement patterns"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Environmental Variations"}),": Day/night, weather, lighting changes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Elements"}),": Moving obstacles, changing layouts"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"safety-and-validation",children:"Safety and Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Example: Safety validation system\nclass SafetyValidator(Node):\n    def __init__(self):\n        super().__init__('safety_validator')\n\n        self.pose_sub = self.create_subscription(\n            PoseStamped, '/robot_pose', self.pose_callback, 10)\n        self.safety_pub = self.create_publisher(Bool, '/safety_violation', 10)\n\n        # Define safety zones\n        self.safety_zones = [\n            {'center': [0, 0], 'radius': 2.0, 'name': 'restricted_area'},\n            {'center': [5, 5], 'radius': 1.0, 'name': 'no_entry_zone'}\n        ]\n\n    def pose_callback(self, msg):\n        pos = msg.pose.position\n        robot_pos = [pos.x, pos.y]\n\n        for zone in self.safety_zones:\n            distance = np.sqrt((robot_pos[0] - zone['center'][0])**2 +\n                             (robot_pos[1] - zone['center'][1])**2)\n\n            if distance < zone['radius']:\n                self.get_logger().warn(f'Safety violation in {zone[\"name\"]}')\n                safety_msg = Bool()\n                safety_msg.data = True\n                self.safety_pub.publish(safety_msg)\n                return\n"})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-for-environment-design",children:"Best Practices for Environment Design"}),"\n",(0,t.jsx)(e.h3,{id:"modularity",children:"Modularity"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Create reusable environment components"}),"\n",(0,t.jsx)(e.li,{children:"Use parameterized environments for flexibility"}),"\n",(0,t.jsx)(e.li,{children:"Implement environment inheritance systems"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"scalability",children:"Scalability"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Design environments that can be easily modified"}),"\n",(0,t.jsx)(e.li,{children:"Use configuration files for environment parameters"}),"\n",(0,t.jsx)(e.li,{children:"Implement progressive difficulty systems"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"validation",children:"Validation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Validate environments against real-world scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Test with multiple robot configurations"}),"\n",(0,t.jsx)(e.li,{children:"Measure computational performance requirements"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,t.jsx)(e.p,{children:"Building comprehensive test environments is crucial for Physical AI development. This chapter covered creating modular environments in both Gazebo and Unity, implementing performance metrics systems, and designing validation frameworks. Well-designed environments enable thorough testing of Physical AI systems before deployment to real hardware."}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create a Gazebo world with multiple rooms and obstacles for navigation testing."}),"\n",(0,t.jsx)(e.li,{children:"Implement a Unity scene with dynamic elements that change over time."}),"\n",(0,t.jsx)(e.li,{children:"Design an evaluation system that measures robot performance in your environments."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(e.p,{children:"In the next chapter, we'll work on a project that integrates all the simulation concepts learned in Module 2, creating an autonomous navigation system in simulation."})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(m,{...n})}):m(n)}}}]);