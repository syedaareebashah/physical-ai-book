"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[2577],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},9206:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module4-vla/cognitive-planning","title":"Cognitive Planning with LLMs","description":"Chapter Objectives","source":"@site/docs/module4-vla/03-cognitive-planning.md","sourceDirName":"module4-vla","slug":"/module4-vla/cognitive-planning","permalink":"/physical-ai-book/docs/module4-vla/cognitive-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/syedaareebashah/physical-ai-book/edit/main/docs/module4-vla/03-cognitive-planning.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Voice-to-Action Pipeline","permalink":"/physical-ai-book/docs/module4-vla/voice-action-pipeline"},"next":{"title":"Multimodal Integration","permalink":"/physical-ai-book/docs/module4-vla/multimodal-integration"}}');var a=t(4848),i=t(8453);const r={sidebar_position:3},o="Cognitive Planning with LLMs",l={},c=[{value:"Chapter Objectives",id:"chapter-objectives",level:2},{value:"Cognitive Planning Overview",id:"cognitive-planning-overview",level:2},{value:"What is Cognitive Planning?",id:"what-is-cognitive-planning",level:3},{value:"Cognitive Planning vs Traditional Planning",id:"cognitive-planning-vs-traditional-planning",level:3},{value:"Cognitive Architecture",id:"cognitive-architecture",level:2},{value:"Hierarchical Planning Structure",id:"hierarchical-planning-structure",level:3},{value:"Cognitive Planning Components",id:"cognitive-planning-components",level:3},{value:"LLM-Enhanced Task Decomposition",id:"llm-enhanced-task-decomposition",level:2},{value:"Hierarchical Task Networks (HTN) with LLMs",id:"hierarchical-task-networks-htn-with-llms",level:3},{value:"Context-Aware Planning",id:"context-aware-planning",level:2},{value:"Dynamic Context Management",id:"dynamic-context-management",level:3},{value:"Multi-Step Reasoning with LLMs",id:"multi-step-reasoning-with-llms",level:2},{value:"Chain-of-Thought Planning",id:"chain-of-thought-planning",level:3},{value:"Learning and Adaptation",id:"learning-and-adaptation",level:2},{value:"Experience-Based Planning Improvement",id:"experience-based-planning-improvement",level:3},{value:"Failure Handling and Recovery",id:"failure-handling-and-recovery",level:2},{value:"Robust Planning with Fallbacks",id:"robust-planning-with-fallbacks",level:3},{value:"Integration with Robot Control",id:"integration-with-robot-control",level:2},{value:"Planning-Execution Bridge",id:"planning-execution-bridge",level:3},{value:"Best Practices for Cognitive Planning",id:"best-practices-for-cognitive-planning",level:2},{value:"1. Layered Architecture",id:"1-layered-architecture",level:3},{value:"2. Context Management",id:"2-context-management",level:3},{value:"3. Failure Handling",id:"3-failure-handling",level:3},{value:"4. Performance Optimization",id:"4-performance-optimization",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"cognitive-planning-with-llms",children:"Cognitive Planning with LLMs"})}),"\n",(0,a.jsx)(n.h2,{id:"chapter-objectives",children:"Chapter Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Design cognitive architectures that integrate LLMs with robotic planning"}),"\n",(0,a.jsx)(n.li,{children:"Implement hierarchical task planning using LLM reasoning"}),"\n",(0,a.jsx)(n.li,{children:"Create context-aware planning systems for Physical AI"}),"\n",(0,a.jsx)(n.li,{children:"Develop multi-step reasoning capabilities for complex tasks"}),"\n",(0,a.jsx)(n.li,{children:"Build robust planning systems that handle uncertainty and failures"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"cognitive-planning-overview",children:"Cognitive Planning Overview"}),"\n",(0,a.jsx)(n.h3,{id:"what-is-cognitive-planning",children:"What is Cognitive Planning?"}),"\n",(0,a.jsx)(n.p,{children:"Cognitive planning in Physical AI refers to the high-level reasoning process that enables robots to understand complex tasks, break them down into manageable steps, and execute them in a context-aware manner. When enhanced with Large Language Models (LLMs), cognitive planning gains the ability to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Understand natural language task descriptions"}),"\n",(0,a.jsx)(n.li,{children:"Apply common sense reasoning"}),"\n",(0,a.jsx)(n.li,{children:"Handle ambiguous or incomplete instructions"}),"\n",(0,a.jsx)(n.li,{children:"Adapt plans based on changing circumstances"}),"\n",(0,a.jsx)(n.li,{children:"Learn from experience and improve over time"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"cognitive-planning-vs-traditional-planning",children:"Cognitive Planning vs Traditional Planning"}),"\n",(0,a.jsx)(n.p,{children:"Traditional robotic planning focuses on:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Low-level path planning and motion planning"}),"\n",(0,a.jsx)(n.li,{children:"Deterministic state transitions"}),"\n",(0,a.jsx)(n.li,{children:"Predefined action sequences"}),"\n",(0,a.jsx)(n.li,{children:"Reactive behavior to environmental changes"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Cognitive planning with LLMs adds:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"High-level task understanding"}),"\n",(0,a.jsx)(n.li,{children:"Commonsense reasoning about the world"}),"\n",(0,a.jsx)(n.li,{children:"Natural language interaction"}),"\n",(0,a.jsx)(n.li,{children:"Adaptive and flexible behavior"}),"\n",(0,a.jsx)(n.li,{children:"Learning from experience"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"cognitive-architecture",children:"Cognitive Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"hierarchical-planning-structure",children:"Hierarchical Planning Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Task Level (LLM)                             \u2502\n\u2502  - High-level task decomposition                                \u2502\n\u2502  - Goal reasoning                                               \u2502\n\u2502  - Context understanding                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Action Level (Planner)                          \u2502\n\u2502  - Action sequence generation                                   \u2502\n\u2502  - Constraint satisfaction                                      \u2502\n\u2502  - Resource allocation                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Execution Level (Robot)                          \u2502\n\u2502  - Low-level motion control                                     \u2502\n\u2502  - Sensor feedback processing                                   \u2502\n\u2502  - Real-time adaptation                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cognitive-planning-components",children:"Cognitive Planning Components"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Goal Parser"}),": Interprets high-level goals from natural language"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"World Model"}),": Maintains understanding of the environment and robot state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Task Decomposer"}),": Breaks complex tasks into subtasks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Action Planner"}),": Generates executable action sequences"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Context Manager"}),": Tracks relevant context and constraints"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Learning Module"}),": Updates knowledge based on experience"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"llm-enhanced-task-decomposition",children:"LLM-Enhanced Task Decomposition"}),"\n",(0,a.jsx)(n.h3,{id:"hierarchical-task-networks-htn-with-llms",children:"Hierarchical Task Networks (HTN) with LLMs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# File: cognitive_planning/htn_planner.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import PoseStamped\nimport json\nimport openai\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass TaskType(Enum):\n    NAVIGATION = "navigation"\n    MANIPULATION = "manipulation"\n    PERCEPTION = "perception"\n    COMPOSITE = "composite"\n\n@dataclass\nclass Task:\n    id: str\n    type: TaskType\n    description: str\n    parameters: Dict[str, Any]\n    dependencies: List[str]\n    status: str = "pending"  # pending, executing, completed, failed\n\nclass HTNPlannerNode(Node):\n    def __init__(self):\n        super().__init__(\'htn_planner_node\')\n\n        # Initialize OpenAI client\n        self.client = openai.OpenAI(api_key=\'your-api-key\')\n\n        # Subscribers\n        self.task_sub = self.create_subscription(\n            String, \'/cognitive/task\', self.task_callback, 10)\n\n        # Publishers\n        self.subtask_pub = self.create_publisher(\n            String, \'/cognitive/subtasks\', 10)\n        self.action_pub = self.create_publisher(\n            String, \'/robot/action\', 10)\n\n        # State\n        self.current_tasks = {}\n        self.world_model = WorldModel()\n\n        self.get_logger().info(\'HTN Planner Node Started\')\n\n    def task_callback(self, msg):\n        """Process high-level task request"""\n        try:\n            task_request = json.loads(msg.data)\n            task_description = task_request[\'description\']\n            task_context = task_request.get(\'context\', {})\n\n            # Use LLM to decompose task\n            subtasks = self.decompose_task(task_description, task_context)\n\n            # Publish subtasks\n            subtasks_msg = String()\n            subtasks_msg.data = json.dumps({\n                \'original_task\': task_description,\n                \'subtasks\': [self.task_to_dict(task) for task in subtasks],\n                \'context\': task_context\n            })\n            self.subtask_pub.publish(subtasks_msg)\n\n            # Execute subtasks\n            self.execute_subtasks(subtasks)\n\n        except json.JSONDecodeError:\n            self.get_logger().error(\'Invalid JSON in task request\')\n\n    def decompose_task(self, task_description: str, context: Dict[str, Any]) -> List[Task]:\n        """Use LLM to decompose high-level task into subtasks"""\n        world_state = self.world_model.get_state()\n\n        prompt = f"""\n        Decompose the following task into a sequence of executable subtasks:\n        Task: "{task_description}"\n\n        Current world state: {world_state}\n        Context: {context}\n\n        Provide a JSON list of subtasks with the following structure:\n        {{\n            "id": "unique_id",\n            "type": "navigation|manipulation|perception|composite",\n            "description": "detailed description",\n            "parameters": {{"key": "value"}},\n            "dependencies": ["task_id_1", "task_id_2"]  // tasks that must complete first\n        }}\n\n        Consider:\n        1. Physical constraints of the robot\n        2. Environmental constraints\n        3. Safety requirements\n        4. Logical dependencies between tasks\n        5. Available robot capabilities\n        """\n\n        try:\n            response = self.client.chat.completions.create(\n                model="gpt-3.5-turbo",\n                messages=[{"role": "user", "content": prompt}],\n                temperature=0.1\n            )\n\n            subtasks_data = json.loads(response.choices[0].message.content)\n\n            subtasks = []\n            for task_data in subtasks_data:\n                task = Task(\n                    id=task_data[\'id\'],\n                    type=TaskType(task_data[\'type\']),\n                    description=task_data[\'description\'],\n                    parameters=task_data.get(\'parameters\', {}),\n                    dependencies=task_data.get(\'dependencies\', [])\n                )\n                subtasks.append(task)\n\n            return subtasks\n\n        except Exception as e:\n            self.get_logger().error(f\'Task decomposition error: {e}\')\n            # Return fallback subtasks\n            return self.create_fallback_subtasks(task_description)\n\n    def create_fallback_subtasks(self, task_description: str) -> List[Task]:\n        """Create fallback subtasks if LLM decomposition fails"""\n        # Simple fallback based on keywords\n        if \'navigate\' in task_description.lower() or \'go to\' in task_description.lower():\n            return [Task(\n                id=\'nav_1\',\n                type=TaskType.NAVIGATION,\n                description=\'Navigate to specified location\',\n                parameters={\'target_location\': \'unknown\'},\n                dependencies=[]\n            )]\n        elif \'pick\' in task_description.lower() or \'grasp\' in task_description.lower():\n            return [Task(\n                id=\'manip_1\',\n                type=TaskType.MANIPULATION,\n                description=\'Manipulate object\',\n                parameters={\'action\': \'pick\', \'object\': \'unknown\'},\n                dependencies=[]\n            )]\n        else:\n            return [Task(\n                id=\'default_1\',\n                type=TaskType.PERCEPTION,\n                description=\'Perceive environment\',\n                parameters={},\n                dependencies=[]\n            )]\n\n    def execute_subtasks(self, subtasks: List[Task]):\n        """Execute subtasks in dependency order"""\n        # Sort tasks by dependencies\n        sorted_tasks = self.topological_sort(subtasks)\n\n        for task in sorted_tasks:\n            self.execute_task(task)\n\n    def topological_sort(self, tasks: List[Task]) -> List[Task]:\n        """Sort tasks in dependency order using topological sort"""\n        # Create adjacency list\n        graph = {task.id: [] for task in tasks}\n        for task in tasks:\n            for dep_id in task.dependencies:\n                if dep_id in graph:\n                    graph[dep_id].append(task.id)\n\n        # Perform topological sort\n        visited = set()\n        result = []\n\n        def dfs(task_id):\n            if task_id in visited:\n                return\n            visited.add(task_id)\n\n            for neighbor in graph[task_id]:\n                dfs(neighbor)\n\n            # Find task object and add to result\n            for task in tasks:\n                if task.id == task_id:\n                    result.append(task)\n                    break\n\n        for task in tasks:\n            if task.id not in visited:\n                dfs(task.id)\n\n        return result\n\n    def execute_task(self, task: Task):\n        """Execute a single task"""\n        self.get_logger().info(f\'Executing task: {task.description}\')\n\n        if task.type == TaskType.NAVIGATION:\n            self.execute_navigation_task(task)\n        elif task.type == TaskType.MANIPULATION:\n            self.execute_manipulation_task(task)\n        elif task.type == TaskType.PERCEPTION:\n            self.execute_perception_task(task)\n        else:\n            self.get_logger().warn(f\'Unknown task type: {task.type}\')\n\n        task.status = \'completed\'\n\n    def execute_navigation_task(self, task: Task):\n        """Execute navigation task"""\n        target = task.parameters.get(\'target_location\', \'unknown\')\n        self.get_logger().info(f\'Navigating to {target}\')\n\n        # Publish navigation goal\n        goal_msg = PoseStamped()\n        goal_msg.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.header.frame_id = \'map\'\n        # Set target coordinates based on task parameters\n        goal_msg.pose.position.x = task.parameters.get(\'x\', 0.0)\n        goal_msg.pose.position.y = task.parameters.get(\'y\', 0.0)\n        goal_msg.pose.position.z = 0.0\n        goal_msg.pose.orientation.w = 1.0\n\n        # In real implementation, this would publish to navigation stack\n        pass\n\n    def execute_manipulation_task(self, task: Task):\n        """Execute manipulation task"""\n        action = task.parameters.get(\'action\', \'unknown\')\n        obj = task.parameters.get(\'object\', \'unknown\')\n        self.get_logger().info(f\'Performing {action} on {obj}\')\n\n        # In real implementation, this would call manipulation services\n        pass\n\n    def execute_perception_task(self, task: Task):\n        """Execute perception task"""\n        perception_type = task.parameters.get(\'type\', \'object_detection\')\n        self.get_logger().info(f\'Performing {perception_type}\')\n\n        # In real implementation, this would call perception services\n        pass\n\n    def task_to_dict(self, task: Task) -> Dict[str, Any]:\n        """Convert task to dictionary for JSON serialization"""\n        return {\n            \'id\': task.id,\n            \'type\': task.type.value,\n            \'description\': task.description,\n            \'parameters\': task.parameters,\n            \'dependencies\': task.dependencies,\n            \'status\': task.status\n        }\n\nclass WorldModel:\n    """Maintains current state of the world for planning"""\n    def __init__(self):\n        self.robot_pose = None\n        self.objects = {}\n        self.environment = {}\n        self.robot_capabilities = {\n            \'navigation\': True,\n            \'manipulation\': False,  # Default to no manipulation\n            \'perception\': True\n        }\n\n    def get_state(self) -> Dict[str, Any]:\n        """Get current world state as dictionary"""\n        return {\n            \'robot_pose\': self.robot_pose,\n            \'objects\': self.objects,\n            \'environment\': self.environment,\n            \'robot_capabilities\': self.robot_capabilities\n        }\n\n    def update_robot_pose(self, pose):\n        """Update robot position in world model"""\n        self.robot_pose = pose\n\n    def update_object(self, object_id: str, properties: Dict[str, Any]):\n        """Update object information in world model"""\n        self.objects[object_id] = properties\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HTNPlannerNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"context-aware-planning",children:"Context-Aware Planning"}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-context-management",children:"Dynamic Context Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# File: cognitive_planning/context_manager.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import PoseStamped\nimport json\nfrom typing import Dict, Any, List\nfrom datetime import datetime\nimport threading\n\nclass ContextManagerNode(Node):\n    def __init__(self):\n        super().__init__('context_manager_node')\n\n        # Subscribers\n        self.task_sub = self.create_subscription(\n            String, '/cognitive/task', self.task_callback, 10)\n        self.scan_sub = self.create_subscription(\n            LaserScan, '/scan', self.scan_callback, 10)\n        self.pose_sub = self.create_subscription(\n            PoseStamped, '/current_pose', self.pose_callback, 10)\n        self.perception_sub = self.create_subscription(\n            String, '/perception/objects', self.perception_callback, 10)\n\n        # Publishers\n        self.context_pub = self.create_publisher(\n            String, '/cognitive/context', 10)\n\n        # Context storage\n        self.context = {\n            'timestamp': datetime.now().isoformat(),\n            'robot_state': {\n                'position': [0, 0, 0],\n                'orientation': [0, 0, 0, 1],\n                'battery_level': 100,\n                'status': 'idle'\n            },\n            'environment': {\n                'obstacles': [],\n                'free_space': [],\n                'navigation_zones': {}\n            },\n            'objects': {},\n            'constraints': {},\n            'history': []\n        }\n\n        # Thread lock for context updates\n        self.context_lock = threading.Lock()\n\n        # Timer for context updates\n        self.context_timer = self.create_timer(1.0, self.publish_context)\n\n        self.get_logger().info('Context Manager Node Started')\n\n    def task_callback(self, msg):\n        \"\"\"Update context with new task information\"\"\"\n        try:\n            task_data = json.loads(msg.data)\n            with self.context_lock:\n                self.context['history'].append({\n                    'type': 'task',\n                    'data': task_data,\n                    'timestamp': datetime.now().isoformat()\n                })\n                self.context['timestamp'] = datetime.now().isoformat()\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in task message')\n\n    def scan_callback(self, msg):\n        \"\"\"Update context with obstacle information\"\"\"\n        with self.context_lock:\n            # Process laser scan to identify obstacles\n            obstacles = []\n            for i, range_val in enumerate(msg.ranges):\n                if msg.range_min <= range_val <= msg.range_max:\n                    angle = msg.angle_min + i * msg.angle_increment\n                    x = range_val * math.cos(angle)\n                    y = range_val * math.sin(angle)\n                    obstacles.append({'x': x, 'y': y, 'distance': range_val})\n\n            self.context['environment']['obstacles'] = obstacles\n            self.context['timestamp'] = datetime.now().isoformat()\n\n    def pose_callback(self, msg):\n        \"\"\"Update context with robot position\"\"\"\n        with self.context_lock:\n            self.context['robot_state']['position'] = [\n                msg.pose.position.x,\n                msg.pose.position.y,\n                msg.pose.position.z\n            ]\n            self.context['robot_state']['orientation'] = [\n                msg.pose.orientation.x,\n                msg.pose.orientation.y,\n                msg.pose.orientation.z,\n                msg.pose.orientation.w\n            ]\n            self.context['timestamp'] = datetime.now().isoformat()\n\n    def perception_callback(self, msg):\n        \"\"\"Update context with object detection results\"\"\"\n        try:\n            objects_data = json.loads(msg.data)\n            with self.context_lock:\n                self.context['objects'] = objects_data\n                self.context['timestamp'] = datetime.now().isoformat()\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in perception message')\n\n    def publish_context(self):\n        \"\"\"Publish current context\"\"\"\n        with self.context_lock:\n            context_msg = String()\n            context_msg.data = json.dumps(self.context)\n            self.context_pub.publish(context_msg)\n\n    def get_context_prompt(self) -> str:\n        \"\"\"Generate context prompt for LLM\"\"\"\n        with self.context_lock:\n            context_str = f\"\"\"\n            Current Context:\n            - Robot Position: {self.context['robot_state']['position']}\n            - Robot Status: {self.context['robot_state']['status']}\n            - Battery Level: {self.context['robot_state']['battery_level']}%\n            - Obstacles Detected: {len(self.context['environment']['obstacles'])}\n            - Objects in Environment: {list(self.context['objects'].keys())}\n            - Navigation Constraints: {self.context['constraints']}\n            - Recent Actions: {[h['type'] for h in self.context['history'][-5:]]}\n            \"\"\"\n            return context_str\n\n    def add_constraint(self, constraint_type: str, constraint_value: Any):\n        \"\"\"Add constraint to context\"\"\"\n        with self.context_lock:\n            if constraint_type not in self.context['constraints']:\n                self.context['constraints'][constraint_type] = []\n            self.context['constraints'][constraint_type].append(constraint_value)\n            self.context['timestamp'] = datetime.now().isoformat()\n\nimport math\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ContextManagerNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"multi-step-reasoning-with-llms",children:"Multi-Step Reasoning with LLMs"}),"\n",(0,a.jsx)(n.h3,{id:"chain-of-thought-planning",children:"Chain-of-Thought Planning"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# File: cognitive_planning/reasoning_engine.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nimport json\nimport openai\nfrom typing import Dict, Any, List, Tuple\n\nclass ReasoningEngineNode(Node):\n    def __init__(self):\n        super().__init__(\'reasoning_engine_node\')\n\n        # Initialize OpenAI client\n        self.client = openai.OpenAI(api_key=\'your-api-key\')\n\n        # Subscribers\n        self.task_sub = self.create_subscription(\n            String, \'/cognitive/high_level_task\', self.task_callback, 10)\n        self.context_sub = self.create_subscription(\n            String, \'/cognitive/context\', self.context_callback, 10)\n\n        # Publishers\n        self.plan_pub = self.create_publisher(\n            String, \'/cognitive/reasoned_plan\', 10)\n\n        # State\n        self.current_context = {}\n\n        self.get_logger().info(\'Reasoning Engine Node Started\')\n\n    def context_callback(self, msg):\n        """Update current context"""\n        try:\n            self.current_context = json.loads(msg.data)\n        except json.JSONDecodeError:\n            self.get_logger().error(\'Invalid JSON in context message\')\n\n    def task_callback(self, msg):\n        """Process high-level task with multi-step reasoning"""\n        try:\n            task_request = json.loads(msg.data)\n            task_description = task_request[\'task\']\n            goal = task_request[\'goal\']\n\n            # Perform chain-of-thought reasoning\n            reasoned_plan = self.reason_about_task(task_description, goal)\n\n            # Publish reasoned plan\n            plan_msg = String()\n            plan_msg.data = json.dumps(reasoned_plan)\n            self.plan_pub.publish(plan_msg)\n\n        except json.JSONDecodeError:\n            self.get_logger().error(\'Invalid JSON in task request\')\n\n    def reason_about_task(self, task: str, goal: str) -> Dict[str, Any]:\n        """Use LLM for multi-step reasoning about task execution"""\n        context = self.current_context\n\n        # Chain-of-thought prompting\n        cot_prompt = f"""\n        Task: {task}\n        Goal: {goal}\n\n        Current Context:\n        {json.dumps(context, indent=2)}\n\n        Let\'s think step by step to create a plan:\n\n        1. What is the current situation?\n        2. What are the requirements to achieve the goal?\n        3. What obstacles or constraints exist?\n        4. What sequence of actions would achieve the goal?\n        5. What are potential failure points and how to handle them?\n\n        Provide your reasoning and then a structured plan in JSON format:\n        {{\n            "reasoning": "step-by-step reasoning process",\n            "plan": [\n                {{\n                    "step": 1,\n                    "action": "action_description",\n                    "reason": "why this action is needed",\n                    "expected_outcome": "what should happen",\n                    "safety_check": "what to verify before/after"\n                }}\n            ],\n            "constraints": ["list of constraints to consider"],\n            "fallbacks": ["list of alternative approaches if primary plan fails"]\n        }}\n        """\n\n        try:\n            response = self.client.chat.completions.create(\n                model="gpt-4",  # Using GPT-4 for better reasoning\n                messages=[{"role": "user", "content": cot_prompt}],\n                temperature=0.3\n            )\n\n            content = response.choices[0].message.content\n\n            # Extract JSON from response if wrapped in code blocks\n            if \'```json\' in content:\n                start = content.find(\'```json\') + 7\n                end = content.find(\'```\', start)\n                json_content = content[start:end].strip()\n            elif \'```\' in content:\n                start = content.find(\'```\') + 3\n                end = content.find(\'```\', start)\n                json_content = content[start:end].strip()\n            else:\n                json_content = content\n\n            return json.loads(json_content)\n\n        except Exception as e:\n            self.get_logger().error(f\'Reasoning error: {e}\')\n            # Return fallback plan\n            return {\n                "reasoning": "Error in reasoning, using fallback",\n                "plan": [{"step": 1, "action": "perceive_environment", "reason": "gather information", "expected_outcome": "environment understanding", "safety_check": "obstacle detection"}],\n                "constraints": ["safety", "navigation", "manipulation"],\n                "fallbacks": ["simple_navigation", "request_help"]\n            }\n\n    def validate_plan(self, plan: Dict[str, Any]) -> Tuple[bool, str]:\n        """Validate the generated plan"""\n        # Check if plan has required structure\n        required_keys = [\'plan\', \'reasoning\']\n        for key in required_keys:\n            if key not in plan:\n                return False, f"Missing required key: {key}"\n\n        # Check if plan has steps\n        if not isinstance(plan[\'plan\'], list) or len(plan[\'plan\']) == 0:\n            return False, "Plan must contain at least one step"\n\n        # Validate each step\n        for i, step in enumerate(plan[\'plan\']):\n            required_step_keys = [\'action\', \'reason\']\n            for key in required_step_keys:\n                if key not in step:\n                    return False, f"Step {i} missing required key: {key}"\n\n        return True, "Plan is valid"\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ReasoningEngineNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"learning-and-adaptation",children:"Learning and Adaptation"}),"\n",(0,a.jsx)(n.h3,{id:"experience-based-planning-improvement",children:"Experience-Based Planning Improvement"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# File: cognitive_planning/learning_module.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom std_msgs.msg import Bool\nimport json\nimport pickle\nimport os\nfrom typing import Dict, Any, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass Experience:\n    task: str\n    plan: List[Dict[str, Any]]\n    outcome: str  # success, partial_success, failure\n    feedback: str\n    timestamp: str\n    execution_time: float\n\nclass LearningModuleNode(Node):\n    def __init__(self):\n        super().__init__('learning_module_node')\n\n        # Subscribers\n        self.plan_sub = self.create_subscription(\n            String, '/cognitive/reasoned_plan', self.plan_callback, 10)\n        self.outcome_sub = self.create_subscription(\n            String, '/cognitive/execution_outcome', self.outcome_callback, 10)\n        self.feedback_sub = self.create_subscription(\n            String, '/user/feedback', self.feedback_callback, 10)\n\n        # Publishers\n        self.adapted_plan_pub = self.create_publisher(\n            String, '/cognitive/adapted_plan', 10)\n\n        # State\n        self.experiences: List[Experience] = []\n        self.current_plan = None\n        self.current_task = None\n        self.start_time = None\n\n        # Load previous experiences\n        self.load_experiences()\n\n        # Timer for periodic learning updates\n        self.learning_timer = self.create_timer(30.0, self.update_knowledge)\n\n        self.get_logger().info('Learning Module Node Started')\n\n    def plan_callback(self, msg):\n        \"\"\"Store plan for learning\"\"\"\n        try:\n            plan_data = json.loads(msg.data)\n            self.current_plan = plan_data\n            self.current_task = plan_data.get('task', 'unknown')\n            self.start_time = datetime.now()\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in plan message')\n\n    def outcome_callback(self, msg):\n        \"\"\"Process execution outcome for learning\"\"\"\n        try:\n            outcome_data = json.loads(msg.data)\n            outcome = outcome_data['outcome']\n            task = outcome_data.get('task', self.current_task)\n\n            if self.start_time:\n                execution_time = (datetime.now() - self.start_time).total_seconds()\n            else:\n                execution_time = 0\n\n            experience = Experience(\n                task=task,\n                plan=self.current_plan,\n                outcome=outcome,\n                feedback=outcome_data.get('feedback', ''),\n                timestamp=datetime.now().isoformat(),\n                execution_time=execution_time\n            )\n\n            self.experiences.append(experience)\n            self.current_plan = None\n            self.current_task = None\n            self.start_time = None\n\n            # Save experience\n            self.save_experiences()\n\n            self.get_logger().info(f'Learned from experience: {outcome} for task {task}')\n\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in outcome message')\n\n    def feedback_callback(self, msg):\n        \"\"\"Process user feedback for learning\"\"\"\n        feedback = msg.data\n        if self.current_plan:\n            # Add feedback to current experience when it completes\n            pass\n\n    def update_knowledge(self):\n        \"\"\"Periodically update knowledge based on experiences\"\"\"\n        if len(self.experiences) < 10:  # Need sufficient experiences\n            return\n\n        # Analyze patterns in experiences\n        patterns = self.analyze_patterns()\n\n        # Update planning strategies based on patterns\n        self.update_planning_strategies(patterns)\n\n        self.get_logger().info(f'Updated knowledge from {len(self.experiences)} experiences')\n\n    def analyze_patterns(self) -> Dict[str, Any]:\n        \"\"\"Analyze patterns in experiences\"\"\"\n        patterns = {\n            'task_success_rates': {},\n            'common_failure_modes': [],\n            'effective_strategies': [],\n            'ineffective_strategies': []\n        }\n\n        # Calculate success rates by task type\n        task_outcomes = {}\n        for exp in self.experiences:\n            task = exp.task\n            if task not in task_outcomes:\n                task_outcomes[task] = {'success': 0, 'total': 0}\n\n            task_outcomes[task]['total'] += 1\n            if exp.outcome == 'success':\n                task_outcomes[task]['success'] += 1\n\n        for task, outcomes in task_outcomes.items():\n            success_rate = outcomes['success'] / outcomes['total']\n            patterns['task_success_rates'][task] = success_rate\n\n        # Identify common failure modes\n        failures = [exp for exp in self.experiences if exp.outcome == 'failure']\n        for failure in failures:\n            # Analyze what went wrong\n            patterns['common_failure_modes'].append({\n                'task': failure.task,\n                'plan_structure': [step['action'] for step in failure.plan.get('plan', [])],\n                'feedback': failure.feedback\n            })\n\n        return patterns\n\n    def update_planning_strategies(self, patterns: Dict[str, Any]):\n        \"\"\"Update planning strategies based on learned patterns\"\"\"\n        # This would update the planning process based on learned patterns\n        # For example, if certain task types have low success rates,\n        # modify the planning approach for those tasks\n\n        # Example: If navigation tasks have low success, add more safety checks\n        if patterns['task_success_rates'].get('navigation', 1.0) < 0.7:\n            self.get_logger().info('Low navigation success rate detected, updating strategies')\n\n    def adapt_plan(self, original_plan: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Adapt plan based on learned experiences\"\"\"\n        adapted_plan = original_plan.copy()\n\n        # Apply learned improvements\n        if 'plan' in adapted_plan:\n            for i, step in enumerate(adapted_plan['plan']):\n                # Apply learned modifications based on task type and context\n                adapted_plan['plan'][i] = self.adapt_step(step)\n\n        return adapted_plan\n\n    def adapt_step(self, step: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Adapt individual step based on learning\"\"\"\n        # Example: Add extra safety checks for actions that previously failed\n        adapted_step = step.copy()\n\n        # Check if this type of action has failed before\n        action_type = step.get('action', '')\n        if self.has_failed_action(action_type):\n            # Add safety verification\n            if 'safety_check' not in adapted_step:\n                adapted_step['safety_check'] = []\n            adapted_step['safety_check'].append('environment_verification')\n\n        return adapted_step\n\n    def has_failed_action(self, action_type: str) -> bool:\n        \"\"\"Check if action type has failed in past experiences\"\"\"\n        for exp in self.experiences:\n            if exp.outcome == 'failure':\n                for step in exp.plan.get('plan', []):\n                    if step.get('action') == action_type:\n                        return True\n        return False\n\n    def save_experiences(self):\n        \"\"\"Save experiences to persistent storage\"\"\"\n        try:\n            with open('/tmp/robot_experiences.pkl', 'wb') as f:\n                pickle.dump(self.experiences, f)\n        except Exception as e:\n            self.get_logger().error(f'Failed to save experiences: {e}')\n\n    def load_experiences(self):\n        \"\"\"Load experiences from persistent storage\"\"\"\n        try:\n            if os.path.exists('/tmp/robot_experiences.pkl'):\n                with open('/tmp/robot_experiences.pkl', 'rb') as f:\n                    self.experiences = pickle.load(f)\n                self.get_logger().info(f'Loaded {len(self.experiences)} experiences')\n        except Exception as e:\n            self.get_logger().info(f'No previous experiences found: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = LearningModuleNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"failure-handling-and-recovery",children:"Failure Handling and Recovery"}),"\n",(0,a.jsx)(n.h3,{id:"robust-planning-with-fallbacks",children:"Robust Planning with Fallbacks"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# File: cognitive_planning/failure_recovery.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom std_msgs.msg import Bool\nimport json\nfrom typing import Dict, Any, List, Optional\nfrom enum import Enum\nimport time\n\nclass RecoveryStrategy(Enum):\n    RETRY = \"retry\"\n    SIMPLIFY = \"simplify\"\n    ALTERNATIVE = \"alternative\"\n    ESCALATE = \"escalate\"\n\nclass FailureRecoveryNode(Node):\n    def __init__(self):\n        super().__init__('failure_recovery_node')\n\n        # Subscribers\n        self.failure_sub = self.create_subscription(\n            String, '/cognitive/failure', self.failure_callback, 10)\n        self.status_sub = self.create_subscription(\n            String, '/robot/status', self.status_callback, 10)\n\n        # Publishers\n        self.recovery_plan_pub = self.create_publisher(\n            String, '/cognitive/recovery_plan', 10)\n        self.emergency_stop_pub = self.create_publisher(\n            Bool, '/emergency_stop', 10)\n\n        # State\n        self.failure_history = []\n        self.current_recovery_level = 0\n        self.max_recovery_attempts = 3\n\n        self.get_logger().info('Failure Recovery Node Started')\n\n    def failure_callback(self, msg):\n        \"\"\"Handle failure and generate recovery plan\"\"\"\n        try:\n            failure_data = json.loads(msg.data)\n            failure_type = failure_data['type']\n            failure_context = failure_data.get('context', {})\n            original_task = failure_data.get('original_task', 'unknown')\n\n            self.get_logger().warn(f'Failure detected: {failure_type}')\n\n            # Record failure\n            self.failure_history.append({\n                'type': failure_type,\n                'context': failure_context,\n                'timestamp': time.time(),\n                'original_task': original_task\n            })\n\n            # Generate recovery plan\n            recovery_plan = self.generate_recovery_plan(\n                failure_type, failure_context, original_task\n            )\n\n            # Publish recovery plan\n            recovery_msg = String()\n            recovery_msg.data = json.dumps(recovery_plan)\n            self.recovery_plan_pub.publish(recovery_msg)\n\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in failure message')\n\n    def generate_recovery_plan(self, failure_type: str, context: Dict[str, Any], original_task: str) -> Dict[str, Any]:\n        \"\"\"Generate recovery plan based on failure type\"\"\"\n        recovery_strategy = self.select_recovery_strategy(failure_type, context)\n\n        if recovery_strategy == RecoveryStrategy.RETRY:\n            return self.create_retry_plan(failure_type, context, original_task)\n        elif recovery_strategy == RecoveryStrategy.SIMPLIFY:\n            return self.create_simplification_plan(failure_type, context, original_task)\n        elif recovery_strategy == RecoveryStrategy.ALTERNATIVE:\n            return self.create_alternative_plan(failure_type, context, original_task)\n        elif recovery_strategy == RecoveryStrategy.ESCALATE:\n            return self.create_escalation_plan(failure_type, context, original_task)\n        else:\n            return self.create_default_recovery_plan(failure_type, context, original_task)\n\n    def select_recovery_strategy(self, failure_type: str, context: Dict[str, Any]) -> RecoveryStrategy:\n        \"\"\"Select appropriate recovery strategy based on failure type and context\"\"\"\n        # Count recent failures of same type\n        recent_failures = [\n            f for f in self.failure_history\n            if f['type'] == failure_type and time.time() - f['timestamp'] < 300  # 5 minutes\n        ]\n\n        if len(recent_failures) >= self.max_recovery_attempts:\n            # Too many failures of same type, escalate\n            return RecoveryStrategy.ESCALATE\n\n        # Select strategy based on failure type\n        strategy_map = {\n            'navigation_failure': RecoveryStrategy.ALTERNATIVE,\n            'manipulation_failure': RecoveryStrategy.SIMPLIFY,\n            'perception_failure': RecoveryStrategy.RETRY,\n            'communication_failure': RecoveryStrategy.RETRY,\n            'safety_violation': RecoveryStrategy.ESCALATE\n        }\n\n        return strategy_map.get(failure_type, RecoveryStrategy.RETRY)\n\n    def create_retry_plan(self, failure_type: str, context: Dict[str, Any], original_task: str) -> Dict[str, Any]:\n        \"\"\"Create plan to retry the failed action\"\"\"\n        return {\n            'strategy': 'retry',\n            'action': 'retry_original',\n            'parameters': context,\n            'max_attempts': 3,\n            'delay': 2.0,  # 2 second delay before retry\n            'original_task': original_task,\n            'recovery_step': self.current_recovery_level\n        }\n\n    def create_simplification_plan(self, failure_type: str, context: Dict[str, Any], original_task: str) -> Dict[str, Any]:\n        \"\"\"Create plan to simplify the task\"\"\"\n        return {\n            'strategy': 'simplify',\n            'action': 'simplified_task',\n            'parameters': {\n                'original_task': original_task,\n                'simplified_goal': self.simplify_task(original_task)\n            },\n            'original_task': original_task,\n            'recovery_step': self.current_recovery_level\n        }\n\n    def create_alternative_plan(self, failure_type: str, context: Dict[str, Any], original_task: str) -> Dict[str, Any]:\n        \"\"\"Create plan with alternative approach\"\"\"\n        return {\n            'strategy': 'alternative',\n            'action': 'alternative_approach',\n            'parameters': {\n                'original_task': original_task,\n                'alternative_methods': self.get_alternative_methods(original_task)\n            },\n            'original_task': original_task,\n            'recovery_step': self.current_recovery_level\n        }\n\n    def create_escalation_plan(self, failure_type: str, context: Dict[str, Any], original_task: str) -> Dict[str, Any]:\n        \"\"\"Create plan to escalate to human operator\"\"\"\n        # Trigger emergency stop if safety-related\n        if 'safety' in failure_type.lower():\n            emergency_msg = Bool()\n            emergency_msg.data = True\n            self.emergency_stop_pub.publish(emergency_msg)\n\n        return {\n            'strategy': 'escalate',\n            'action': 'request_human_assistance',\n            'parameters': {\n                'failure_type': failure_type,\n                'context': context,\n                'original_task': original_task\n            },\n            'original_task': original_task,\n            'recovery_step': self.current_recovery_level\n        }\n\n    def create_default_recovery_plan(self, failure_type: str, context: Dict[str, Any], original_task: str) -> Dict[str, Any]:\n        \"\"\"Create default recovery plan\"\"\"\n        return {\n            'strategy': 'default',\n            'action': 'safe_return',\n            'parameters': {\n                'return_location': 'home_base',\n                'safety_check': True\n            },\n            'original_task': original_task,\n            'recovery_step': self.current_recovery_level\n        }\n\n    def simplify_task(self, task: str) -> str:\n        \"\"\"Simplify a complex task\"\"\"\n        # Example simplifications\n        if 'complex navigation' in task.lower():\n            return task.replace('complex navigation', 'simple navigation')\n        elif 'precise manipulation' in task.lower():\n            return task.replace('precise manipulation', 'basic manipulation')\n        else:\n            return f\"basic version of {task}\"\n\n    def get_alternative_methods(self, task: str) -> List[str]:\n        \"\"\"Get alternative methods for a task\"\"\"\n        alternatives = {\n            'navigation': ['alternative_path', 'different_approach', 'wait_and_retry'],\n            'manipulation': ['different_grip', 'alternative_approach', 'tool_assistance'],\n            'perception': ['different_sensor', 'change_viewpoint', 'illumination_change']\n        }\n\n        for key, methods in alternatives.items():\n            if key in task.lower():\n                return methods\n\n        return ['general_alternative']\n\n    def status_callback(self, msg):\n        \"\"\"Monitor robot status for proactive recovery\"\"\"\n        try:\n            status = json.loads(msg.data)\n            robot_state = status.get('state', 'unknown')\n\n            # Check for states that might indicate potential failures\n            if robot_state in ['stuck', 'error', 'low_battery']:\n                self.get_logger().info(f'Potential issue detected: {robot_state}')\n                # Could trigger proactive recovery measures\n\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in status message')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = FailureRecoveryNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-robot-control",children:"Integration with Robot Control"}),"\n",(0,a.jsx)(n.h3,{id:"planning-execution-bridge",children:"Planning-Execution Bridge"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# File: cognitive_planning/execution_bridge.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom action_msgs.msg import GoalStatus\nfrom rclpy.action import ActionClient\nfrom nav2_msgs.action import NavigateToPose\nfrom typing import Dict, Any, Optional\nimport time\nimport threading\n\nclass ExecutionBridgeNode(Node):\n    def __init__(self):\n        super().__init__('execution_bridge_node')\n\n        # Subscribers\n        self.plan_sub = self.create_subscription(\n            String, '/cognitive/reasoned_plan', self.plan_callback, 10)\n        self.recovery_plan_sub = self.create_subscription(\n            String, '/cognitive/recovery_plan', self.recovery_plan_callback, 10)\n\n        # Publishers\n        self.status_pub = self.create_publisher(\n            String, '/cognitive/execution_status', 10)\n        self.outcome_pub = self.create_publisher(\n            String, '/cognitive/execution_outcome', 10)\n\n        # Action clients\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n\n        # State\n        self.current_plan = None\n        self.plan_thread = None\n        self.execution_active = False\n\n        self.get_logger().info('Execution Bridge Node Started')\n\n    def plan_callback(self, msg):\n        \"\"\"Execute a new plan\"\"\"\n        try:\n            plan = json.loads(msg.data)\n            self.execute_plan(plan)\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in plan message')\n\n    def recovery_plan_callback(self, msg):\n        \"\"\"Execute a recovery plan\"\"\"\n        try:\n            recovery_plan = json.loads(msg.data)\n            self.execute_recovery_plan(recovery_plan)\n        except json.JSONDecodeError:\n            self.get_logger().error('Invalid JSON in recovery plan message')\n\n    def execute_plan(self, plan: Dict[str, Any]):\n        \"\"\"Execute a cognitive plan\"\"\"\n        if self.execution_active:\n            self.get_logger().warn('Plan execution already active, skipping')\n            return\n\n        self.execution_active = True\n        self.current_plan = plan\n\n        # Execute in separate thread to avoid blocking\n        self.plan_thread = threading.Thread(\n            target=self.execute_plan_thread,\n            args=(plan,)\n        )\n        self.plan_thread.start()\n\n    def execute_plan_thread(self, plan: Dict[str, Any]):\n        \"\"\"Execute plan in separate thread\"\"\"\n        start_time = time.time()\n        success_count = 0\n        total_steps = len(plan.get('plan', []))\n\n        for i, step in enumerate(plan.get('plan', [])):\n            self.publish_status(f'Executing step {i+1}/{total_steps}: {step.get(\"action\", \"unknown\")}')\n\n            try:\n                step_success = self.execute_step(step)\n                if step_success:\n                    success_count += 1\n                    self.get_logger().info(f'Step {i+1} completed successfully')\n                else:\n                    self.get_logger().warn(f'Step {i+1} failed')\n                    # Could trigger recovery here\n                    break\n\n            except Exception as e:\n                self.get_logger().error(f'Step {i+1} execution error: {e}')\n                break\n\n        execution_time = time.time() - start_time\n        overall_success = success_count == total_steps\n\n        # Publish outcome\n        outcome = {\n            'task': plan.get('task', 'unknown'),\n            'outcome': 'success' if overall_success else 'partial_success' if success_count > 0 else 'failure',\n            'success_steps': success_count,\n            'total_steps': total_steps,\n            'execution_time': execution_time,\n            'timestamp': time.time()\n        }\n\n        outcome_msg = String()\n        outcome_msg.data = json.dumps(outcome)\n        self.outcome_pub.publish(outcome_msg)\n\n        self.execution_active = False\n\n    def execute_step(self, step: Dict[str, Any]) -> bool:\n        \"\"\"Execute a single step of the plan\"\"\"\n        action = step.get('action', 'unknown')\n\n        if action == 'navigate_to_pose':\n            return self.execute_navigation_step(step)\n        elif action == 'move_robot':\n            return self.execute_move_step(step)\n        elif action == 'perceive_environment':\n            return self.execute_perception_step(step)\n        elif action == 'wait':\n            return self.execute_wait_step(step)\n        else:\n            self.get_logger().warn(f'Unknown action: {action}')\n            return False\n\n    def execute_navigation_step(self, step: Dict[str, Any]) -> bool:\n        \"\"\"Execute navigation step\"\"\"\n        target = step.get('parameters', {}).get('target', {})\n\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.pose.position.x = target.get('x', 0.0)\n        goal_msg.pose.pose.position.y = target.get('y', 0.0)\n        goal_msg.pose.pose.position.z = target.get('z', 0.0)\n        goal_msg.pose.pose.orientation.w = 1.0\n\n        # Wait for action server\n        if not self.nav_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error('Navigation action server not available')\n            return False\n\n        # Send goal\n        future = self.nav_client.send_goal_async(goal_msg)\n        rclpy.spin_until_future_complete(self, future)\n\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error('Navigation goal rejected')\n            return False\n\n        # Get result\n        result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self, result_future)\n\n        result = result_future.result().result\n        status = result_future.result().status\n\n        return status == GoalStatus.STATUS_SUCCEEDED\n\n    def execute_move_step(self, step: Dict[str, Any]) -> bool:\n        \"\"\"Execute simple movement step\"\"\"\n        cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n\n        cmd = Twist()\n        cmd.linear.x = step.get('parameters', {}).get('linear_velocity', 0.0)\n        cmd.angular.z = step.get('parameters', {}).get('angular_velocity', 0.0)\n\n        # Execute for specified duration\n        duration = step.get('parameters', {}).get('duration', 1.0)\n\n        start_time = time.time()\n        while time.time() - start_time < duration:\n            cmd_pub.publish(cmd)\n            time.sleep(0.1)\n\n        # Stop\n        cmd.linear.x = 0.0\n        cmd.angular.z = 0.0\n        cmd_pub.publish(cmd)\n\n        return True\n\n    def execute_perception_step(self, step: Dict[str, Any]) -> bool:\n        \"\"\"Execute perception step\"\"\"\n        # In real implementation, this would call perception services\n        # For now, simulate perception by publishing a message\n        self.get_logger().info('Performing perception task')\n        return True\n\n    def execute_wait_step(self, step: Dict[str, Any]) -> bool:\n        \"\"\"Execute wait step\"\"\"\n        duration = step.get('parameters', {}).get('duration', 1.0)\n        time.sleep(duration)\n        return True\n\n    def execute_recovery_plan(self, recovery_plan: Dict[str, Any]):\n        \"\"\"Execute a recovery plan\"\"\"\n        strategy = recovery_plan.get('strategy', 'unknown')\n        self.get_logger().info(f'Executing recovery strategy: {strategy}')\n\n        if strategy == 'retry':\n            self.execute_retry(recovery_plan)\n        elif strategy == 'simplify':\n            self.execute_simplification(recovery_plan)\n        elif strategy == 'alternative':\n            self.execute_alternative(recovery_plan)\n        elif strategy == 'escalate':\n            self.execute_escalation(recovery_plan)\n\n    def execute_retry(self, recovery_plan: Dict[str, Any]):\n        \"\"\"Execute retry strategy\"\"\"\n        # Implementation would retry the failed action\n        pass\n\n    def execute_simplification(self, recovery_plan: Dict[str, Any]):\n        \"\"\"Execute simplification strategy\"\"\"\n        # Implementation would execute simplified version\n        pass\n\n    def execute_alternative(self, recovery_plan: Dict[str, Any]):\n        \"\"\"Execute alternative strategy\"\"\"\n        # Implementation would try alternative approach\n        pass\n\n    def execute_escalation(self, recovery_plan: Dict[str, Any]):\n        \"\"\"Execute escalation strategy\"\"\"\n        # Implementation would request human assistance\n        pass\n\n    def publish_status(self, status: str):\n        \"\"\"Publish execution status\"\"\"\n        status_msg = String()\n        status_msg.data = json.dumps({\n            'status': status,\n            'timestamp': time.time()\n        })\n        self.status_pub.publish(status_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ExecutionBridgeNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-for-cognitive-planning",children:"Best Practices for Cognitive Planning"}),"\n",(0,a.jsx)(n.h3,{id:"1-layered-architecture",children:"1. Layered Architecture"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Separate high-level reasoning from low-level execution"}),"\n",(0,a.jsx)(n.li,{children:"Use appropriate abstraction levels for different planning components"}),"\n",(0,a.jsx)(n.li,{children:"Implement clear interfaces between components"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-context-management",children:"2. Context Management"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Maintain comprehensive world state"}),"\n",(0,a.jsx)(n.li,{children:"Update context in real-time as environment changes"}),"\n",(0,a.jsx)(n.li,{children:"Use context for adaptive planning"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-failure-handling",children:"3. Failure Handling"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Design robust failure detection mechanisms"}),"\n",(0,a.jsx)(n.li,{children:"Implement multiple recovery strategies"}),"\n",(0,a.jsx)(n.li,{children:"Learn from failures to improve future performance"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"4-performance-optimization",children:"4. Performance Optimization"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cache frequently used plans and patterns"}),"\n",(0,a.jsx)(n.li,{children:"Use appropriate planning horizons"}),"\n",(0,a.jsx)(n.li,{children:"Balance planning quality with execution speed"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,a.jsx)(n.p,{children:"Cognitive planning with LLMs enables robots to perform high-level reasoning and task decomposition that goes beyond traditional planning approaches. By integrating LLMs with contextual awareness, learning capabilities, and robust failure handling, Physical AI systems can achieve more flexible and adaptive behavior. The key components include hierarchical task decomposition, context-aware reasoning, learning from experience, and robust execution with recovery mechanisms."}),"\n",(0,a.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Implement a cognitive planning system that can decompose complex household tasks."}),"\n",(0,a.jsx)(n.li,{children:"Add learning capabilities to improve planning based on execution outcomes."}),"\n",(0,a.jsx)(n.li,{children:"Create a context-aware planning system that adapts to environmental changes."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"In the next chapter, we'll explore multimodal integration, learning how to combine vision, language, and action in Physical AI systems for more sophisticated capabilities."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);